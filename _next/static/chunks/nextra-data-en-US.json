{"/posts/Cairo":{"title":"StarkWareì˜ Cairo ì–¸ì–´ê°€ í”„ë¡œê·¸ë¨ì˜ ìœ íš¨ì„±ì„ ì¦ëª…í•˜ëŠ” ë°©ë²•","data":{"":"[StarkWare series] Cairoê°€ í”„ë¡œê·¸ë¨ì˜ ìœ íš¨ì„±ì„ ì¦ëª…í•˜ëŠ”Â ë°©ë²•\r\nTL;DR\r\në³¸ ê²Œì‹œê¸€ì—ì„œëŠ” ìŠ¤íƒ€í¬ì›¨ì–´ ìƒíƒœê³„ì—ì„œ í•œ ì¶•ì„ ë‹´ë‹¹í•˜ê³  ìˆëŠ” í”„ë¡œê·¸ë˜ë° ì–¸ì–´ Cairoì— ëŒ€í•´ ì‚´í´ë³¸ë‹¤. CairoëŠ” ì¦ëª… ê°€ëŠ¥í•œ í”„ë¡œê·¸ë¨ì„ ì‘ì„±í•˜ê¸° ìœ„í•´ ê°œë°œëœ ì–¸ì–´ì´ë©°, ì´ë¥¼ êµ¬í˜„í•˜ê¸° ìœ„í•´ CPU ì•„í‚¤í…ì²˜ê°€ ì œì•ˆë˜ì—ˆë‹¤. ì´ Cairo ì•„í‚¤í…ì²˜ë¥¼ í†µí•´ ì–´ë–»ê²Œ í”„ë¡œê·¸ë¨ì˜ ìœ íš¨ì„±ì„ ê²€ì¦í•˜ëŠ”ì§€ ê·¸ ê³¼ì •ì„ ì‚´í´ë³´ë„ë¡ í•œë‹¤. ë³¸ ê²Œì‹œê¸€ì€ Cairo WhitepaperÂ : \"Cairoâ€Š-â€Ša Turing-complete STARK-friendly CPU architecture\" ê¸°ë°˜ìœ¼ë¡œ ì‘ì„±ë˜ì—ˆìœ¼ë©°, êµ¬ë…ìê°€. ì»´í“¨í„° ì•„í‚¤í…ì²˜ì— ëŒ€í•œ ê¸°ë³¸ì ì¸ ì§€ì‹(í° ë…¸ì´ë§Œ êµ¬ì¡°, ë ˆì§€ìŠ¤í„°, ë©”ëª¨ë¦¬, instruction ë“±)ì„ ê°–ì¶”ê³  ìˆë‹¤ê³  ê°€ì •í•˜ì˜€ë‹¤.\r\nìš©ì–´ ì •ë¦¬\r\nProverÂ : 'ì´ ê³„ì‚°ì´ ë¬´ê²°í•˜ë‹¤'ëŠ” ê²ƒì„ ì¦ëª…í•˜ê³  ì‹¶ì€ ì°¸ì—¬ì\r\nVerifierÂ : ê³„ì‚°ì˜ ë¬´ê²°ì„±ì„ ê²€ì¦í•˜ê³  ì‹¶ì€ ì°¸ì—¬ì\r\nProofÂ : ìœ íš¨í•œ ê³„ì‚°ì˜ ì¦ëª…\r\nInstructionÂ : CPUê°€ ì‘ì„±ëœ í”„ë¡œê·¸ë¨ì„ ìˆ˜í–‰í•˜ê¸° ìœ„í•´ ì‹¤ì œë¡œ ë™ì‘í•˜ëŠ” ë‹¨ìœ„ì˜ ëª…ë ¹ì–´\r\nCairo í”„ë¡œê·¸ë¨Â : Cairo ì–¸ì–´ë¡œ ì‘ì„±ëœ ì„ì˜ì˜ í”„ë¡œê·¸ë¨Cairoë€?\r\nìŠ¤íƒ€í¬ì›¨ì–´ê°€ ì¦ëª…ì„ íš¨ìœ¨ì ìœ¼ë¡œ ìƒì„±í•˜ê³  ê²€ì¦í•˜ê¸° ìœ„í•´, ê·¸ë¦¬ê³  ê³µí†µëœ ì—°ì‚° ê³¼ì •ì„ ì‚¬ìš©í•˜ì—¬ ë‹¤ì–‘í•œ ë¹„ì¦ˆë‹ˆìŠ¤ ë¡œì§ì— ëŒ€í•œ ì¦ëª…ì„ ìƒì„±í•˜ê¸° ìœ„í•´ Cairoë¼ëŠ” í”„ë¡œê·¸ë˜ë° ì–¸ì–´ ë° ì‹¤í–‰ í™˜ê²½ í”„ë¡œê·¸ë¨ì„ ê°œë°œí–ˆë‹¤.\r\në‹¤ë¥¸ í”„ë¡œê·¸ë˜ë° ì–¸ì–´ì™€ ë‹¬ë¦¬ CairoëŠ” ì¦ëª… ê°€ëŠ¥í•œ í”„ë¡œê·¸ë¨ì„ ì‘ì„±í•˜ê¸° ìœ„í•´ ê°œë°œë˜ì—ˆê³ , ì´ë¥¼ ìœ„í•´ ìŠ¤íƒ€í¬ì›¨ì–´ íŒ€ì€ Turing-complete STARK-friendly CPU architectureë¥¼ ì œì•ˆí•˜ì˜€ë‹¤.\r\nWe present Cairo, and efficient and practical von Neumann architecture that can be used with the STARK proof system to generate proofs of computational integrity (Cairo Whitepaper 1.2 Our contribution)\r\nCairo í”„ë¡œê·¸ë¨ì˜ ê²€ì¦ ê³¼ì •ì„ ìš”ì•½í•˜ìë©´ ì¦ëª…í•˜ê³ ì í•˜ëŠ” í”„ë¡œê·¸ë¨ì„ Cairoë¡œ ì‘ì„±í•œ í›„, ì‘ì„±ëœ í”„ë¡œê·¸ë¨ì„ ì‹¤í–‰í•˜ë©´ execution traceë¥¼ ì–»ì„ ìˆ˜ ìˆìœ¼ë©° proverëŠ” ì´ traceë¥¼ í†µí•´ STARK proofë¥¼ ë§Œë“¤ ìˆ˜ ìˆë‹¤. ê·¸ë¦¬ê³  ì´ proofë¥¼ verifierê°€ ê²€ì¦í•˜ê²Œ ë˜ëŠ” êµ¬ì¡°ì´ë‹¤.\r\nì¶œì²˜: https://www.cairo-lang.org/cairo-for-blockchain-developers/ë³¸ ì•„í‹°í´ì—ì„œëŠ” traceê°€ ì–´ë–»ê²Œ ìƒì„±ë˜ëŠ”ì§€, ì´ë¥¼ í†µí•´ ì–´ë–»ê²Œ proofë¥¼ ë§Œë“¤ê²Œ ë˜ëŠ”ì§€ ì•Œì•„ë³¼ ê²ƒì´ë‹¤.\r\nCairoì˜ íŠ¹ì§•\r\nì•ì„œ ì–¸ê¸‰í–ˆë˜ Cairoì˜ ë””ìì¸ ëª©ì ì€ ë‹¤ìŒê³¼ ê°™ë‹¤.\r\nì¦ëª… ê°€ëŠ¥í•œ statementsë¡œ ì“°ì´ëŠ” í”„ë¡œê·¸ë¨ì„ ì‰½ê²Œ ì‘ì„±í•˜ê³  ì½ê¸° ìœ„í•¨\r\nSTARK proof system ê¸°ë°˜ìœ¼ë¡œ íš¨ìœ¨ì ì¸ ì¦ëª…ì„ ìƒì„±í•˜ê¸° ìœ„í•¨ì´ ëª©ì ì„ ìœ„í•œ Cairo êµ¬í˜„ì—ì„œ í•µì‹¬ì ì¸ íŠ¹ì§•ì€ ë°”ë¡œ ë©”ëª¨ë¦¬ êµ¬ì¡°ì´ë‹¤. Cairo ì•„í‚¤í…ì²˜ì—ì„œëŠ” \"Nondeterministic Continuous Read-Only Random-Access Memory\" ë©”ëª¨ë¦¬ ëª¨ë¸ì„ ì‚¬ìš©í•œë‹¤. ì „í†µì ì¸ Random-access read-write memory ëª¨ë¸ì—ì„œëŠ” instructionì´ ì„ì˜ì˜ ë©”ëª¨ë¦¬ ì£¼ì†Œë¥¼ ì„ íƒí•˜ê³ , ë©”ëª¨ë¦¬ ê°’ì„ ì½ê±°ë‚˜ ìƒˆë¡œìš´ ê°’ì„ ì“°ê²Œ í•  ìˆ˜ ìˆë‹¤. ê·¸ëŸ¬ë‚˜ Nondeterministic Continuous Read-Only Random-Access Memory ëª¨ë¸ì—ì„œëŠ” ë©”ëª¨ë¦¬ ê°’ì´ ë³€í•˜ì§€ ì•Šê³ , ì´ë¯¸ ê°’ì´ ìˆëŠ” ì£¼ì†Œì˜ ê²½ìš° Cairo í”„ë¡œê·¸ë¨ì€ ë©”ëª¨ë¦¬ ê°’ì„ ì½ëŠ” (read) ì‘ì—…ë§Œ ê°€ëŠ¥í•˜ë‹¤. ì´ë¥¼ í†µí•´ ì–»ì„ ìˆ˜ ìˆëŠ” ì´ì ì€ ë‹¤ìŒê³¼ ê°™ë‹¤.\r\nAIR ê³¼ì •ì—ì„œ í•„ìš”í•œ ê°’ë“¤ì„ ë©”ëª¨ë¦¬ì— ì ‘ê·¼í•´ì„œ ê°€ì ¸ì˜¤ëŠ” ì‘ì—…ì´ ê°„ë‹¨í•´ì§„ë‹¤.\r\nProverê°€ verifierì—ê²Œ \"ì´ ë©”ëª¨ë¦¬ ì£¼ì†ŒëŠ” ì´ ê°’ì„ ê°€ì§„ë‹¤.\"ë¼ê³  ì¦ëª…í•˜ëŠ” ì‘ì—…ì´ ê°„ë‹¨í•´ì§„ë‹¤.Trace, Stateë€ ë¬´ì—‡ì¸ê°€? Cairo í”„ë¡œê·¸ë¨ì´ ì‹¤í–‰ë˜ëŠ”Â ë‹¨ê³„\r\nì•ì„œ ì „ì²´ì ì¸ ê°œë…ì„ ì„¤ëª…í•˜ë©´ì„œ Cairo ì–¸ì–´ë¡œ ì‘ì„±ëœ í”„ë¡œê·¸ë¨ì„ ì‹¤í–‰í•˜ë©´ traceë¥¼ ì–»ì„ ìˆ˜ ìˆë‹¤ê³  í–ˆëŠ”ë°, ë„ëŒ€ì²´ ì´ traceê°€ ë¬´ì—‡ì´ê¸¸ë˜ Cairoë¡œ ì‘ì„±ëœ í”„ë¡œê·¸ë¨ì˜ ì¦ëª…ì„ ê°€ëŠ¥í•˜ê²Œ í•˜ëŠ” ê²ƒì¼ê¹Œ?\r\nê²°ë¡ ë¶€í„° ë§í•˜ìë©´ traceëŠ” í”„ë¡œê·¸ë¨ì„ ì‹¤í–‰í•˜ë©´ì„œ ì‚¬ìš©í•œ ë©”ëª¨ë¦¬ ì£¼ì†Œì˜ ë‚˜ì—´ì´ë‹¤. Cairoì˜ ë©”ëª¨ë¦¬ ë””ìì¸ ë•ë¶„ì— ë©”ëª¨ë¦¬ ê°’ì„ ë®ì–´ì“¸ ìˆ˜ ì—†ê³ , ì´ëŠ” í”„ë¡œê·¸ë¨ì„ ì‹¤í–‰í•˜ë©´ì„œ ì‚¬ìš©í•œ ê°’ì´ ìœ ì‹¤ë˜ì§€ ì•ŠìŒì„ ëœ»í•œë‹¤.\r\nCairo ì–¸ì–´ë¡œ ì‘ì„±ëœ í”„ë¡œê·¸ë¨ì´ ì‹¤í–‰ë˜ëŠ” ê³¼ì •ì€ ì•„ë˜ì™€ ê°™ì´ ê°„ë‹¨íˆ ì •ë¦¬í•  ìˆ˜ ìˆìœ¼ë©°, ìì„¸í•œ ë‚´ìš©ì€ [1]ì˜ Chapter 3.5, 3.6ì—ì„œ í™•ì¸í•  ìˆ˜ ìˆë‹¤.\r\nCairo í”„ë¡œê·¸ë¨ì˜ ì¦ëª…Â ê³¼ì •\r\në§Œì•½ \"í”¼ë³´ë‚˜ì¹˜ ìˆ˜ì—´ì˜ jë²ˆì§¸ ìˆ˜ëŠ” yë‹¤\" ë¼ëŠ” ë¬¸ì¥ì„ ì¦ëª…í•˜ê³  ì‹¶ë‹¤ë©´, ì•„ë˜ì™€ ê°™ì€ ê³¼ì •ì„ ê±°ì³ì•¼ í•œë‹¤.\r\nê³„ì‚°ì„ ìœ„í•œ Cairo í”„ë¡œê·¸ë¨ì„ ì‘ì„±í•œë‹¤.\r\nì‘ì„±ëœ í”„ë¡œê·¸ë¨ì„ Cairo ë°”ì´íŠ¸ì½”ë“œë¡œ ë³€í™˜í•œë‹¤.\r\nCairo Runnerê°€ ë°”ì´íŠ¸ì½”ë“œë¥¼ ì‹¤í–‰í•˜ì—¬ execution trace S, partial memory function m*, full memory function mì„ ì–»ëŠ”ë‹¤.\r\nSTARK proverë¡œ ì•„ë˜ statementì— ëŒ€í•œ proofë¥¼ ìƒì„±í•œë‹¤.\"nondeterministic Cairo machineì€ inputì´ ( T, m*, pc_I, pc_F, ap_I, ap_F )ì¼ ë•Œ accept í•œë‹¤.\"\r\nìœ„ statementì—ì„œ ê° inputì´ ì˜ë¯¸í•˜ëŠ” ë°”ëŠ” ë‹¤ìŒê³¼ ê°™ë‹¤.\r\nTÂ : ì‹¤í–‰í•œ í”„ë¡œê·¸ë¨ì˜ ì—°ì‚° step ê°œìˆ˜\r\nm*Â : ë¶€ë¶„ ë©”ëª¨ë¦¬ í•¨ìˆ˜\r\npc_IÂ : ì´ˆê¸° pc ë ˆì§€ìŠ¤í„°ì˜ ê°’\r\npc_FÂ : ìµœì¢… pc ë ˆì§€ìŠ¤í„°ì˜ ê°’\r\nap_IÂ : ì´ˆê¸° apë ˆì§€ìŠ¤í„°ì˜ ê°’\r\nap_FÂ : ìµœì¢… apë ˆì§€ìŠ¤í„°ì˜ ê°’ì•ì„œ Cairo ì•„í‚¤í…ì²˜ëŠ” Nondeterministic Continuous Read-Only Random-Access Memory ë””ìì¸ì„ ì‚¬ìš©í•œë‹¤ê³  í–ˆëŠ”ë°, ì´ëŸ¬í•œ ë©”ëª¨ë¦¬ ë””ìì¸ ë•ë¶„ì— í•˜ë‚˜ì˜ instruction(ì‰½ê²Œ ìƒê°í•´ì„œ ì½”ë“œ í•œ ì¤„)ì´ ì‹¤í–‰ë  ë•Œë§ˆë‹¤ ì´ë¯¸ ì‚¬ìš©ëœ ë©”ëª¨ë¦¬ì˜ ê°’ í™•ì¸(read)ë§Œ ê°€ëŠ¥í•˜ë„ë¡ ìœ ì§€ë˜ë©°, writeëŠ” ì‚¬ìš©ë˜ì§€ ì•Šì€ ë©”ëª¨ë¦¬ì—ë§Œ í—ˆìš©ë˜ë¯€ë¡œ í”„ë¡œê·¸ë¨ì´ ì‹¤í–‰ë˜ë©´ì„œ ì‚¬ìš©í•œ ëª¨ë“  ë©”ëª¨ë¦¬ ê°’ì„ í™•ì¸í•  ìˆ˜ ìˆë‹¤.\r\në”°ë¼ì„œ í”„ë¡œê·¸ë¨ì˜ ì‹¤í–‰ ë‹¨ê³„ì—ì„œì˜ pc, ap, fpë¼ëŠ” íŠ¹ì • ë ˆì§€ìŠ¤í„° ê°’ì„ ë‚˜ì—´í•  ìˆ˜ ìˆê³  ì´ë¥¼ execution trace ë¼ê³  í•œë‹¤.\r\në³´ì¶© ì„¤ëª…Â : Cairoì˜ pc, ap, fp ë ˆì§€ìŠ¤í„°\r\npc (program counter)Â : í˜„ì¬ ì‹¤í–‰ë˜ëŠ” instructionì˜ ë©”ëª¨ë¦¬ ì£¼ì†Œë¥¼ ê°€ë¦¬í‚¨ë‹¤.\r\nap (allocation pointer)Â : [convention] ì•„ì§ ì‚¬ìš©ë˜ì§€ ì•Šì€ ë©”ëª¨ë¦¬ ì£¼ì†Œ ì¤‘ ì²« ì£¼ì†Œë¥¼ ê°€ë¦¬í‚¤ë©°, í”„ë¡œê·¸ë˜ë¨¸ê°€ ë‹¤ë¥¸ ë°©í–¥ìœ¼ë¡œ ì“¸ ìˆ˜ë„ ìˆë‹¤.\r\nfp (frame pointer)Â : í˜„ì¬ functionì˜ ìŠ¤íƒ ë©”ëª¨ë¦¬ ì‹œì‘ì ì„ ê°€ë¦¬í‚¤ëŠ” ë ˆì§€ìŠ¤í„°(cf. RISC-Vì˜ sp)ë¡œ, í•¨ìˆ˜ê°€ ì‹œì‘ë˜ë©´ apì™€ ê°™ì€ ì£¼ì†Œë¥¼ ê°€ë¦¬í‚¤ë‹¤ê°€ í•¨ìˆ˜ê°€ ë¦¬í„´ë˜ë©´ ë‹¤ì‹œ ì´ì „ì— ê°€ë¦¬í‚¤ë˜ ì£¼ì†Œë¥¼ ê°€ë¦¬í‚¨ë‹¤.Cairoì˜ ë ˆì§€ìŠ¤í„°ì™€ traceë¥¼ ì´í•´í–ˆë‹¤ë©´, ë‹¤ì‹œ Cairo í”„ë¡œê·¸ë¨ì˜ ì¦ëª… ê³¼ì •ì„ êµ¬ì²´ì ìœ¼ë¡œ ì‚´í´ë³´ì.\r\nCairo í”„ë¡œê·¸ë¨ì˜ ì¦ëª… ê³¼ì •Â : 1. Cairo ProgramÂ ì‘ì„±\r\ní•˜ë‚˜ì˜ Cairo programì´ ì‹¤í–‰ë˜ëŠ” ê³¼ì •ì„ ì´í•´í•˜ê¸° ìœ„í•´, í”¼ë³´ë‚˜ì¹˜ í”„ë¡œê·¸ë¨ì„ ì˜ˆì‹œë¡œ ì‚´í´ë³´ì. ì•ì„œ ì–¸ê¸‰í•œ 4ë‹¨ê³„ì˜ ê³¼ì • ì¤‘ 1ë‹¨ê³„ì— í•´ë‹¹í•œë‹¤.\r\nê³„ì‚°ì„ ìœ„í•œ Cairo í”„ë¡œê·¸ë¨ì„ ì‘ì„±í•œë‹¤.\r\nì‘ì„±ëœ í”„ë¡œê·¸ë¨ì„ Cairo ë°”ì´íŠ¸ì½”ë“œë¡œ ë³€í™˜í•œë‹¤.\r\nCairo Runnerê°€ ë°”ì´íŠ¸ì½”ë“œë¥¼ ì‹¤í–‰í•˜ì—¬ execution trace S, partial memory function m*, full memory function mì„ ì–»ëŠ”ë‹¤.\r\nSTARK proverë¡œ ì•„ë˜ statementì— ëŒ€í•œ proofë¥¼ ìƒì„±í•œë‹¤.\"nondeterministic Cairo machineì€ inputì´ ( T, m*, pc_I, pc_F, ap_I, ap_F )ì¼ ë•Œ accept í•œë‹¤.\"\r\një²ˆì§¸ í”¼ë³´ë‚˜ì¹˜ ìˆ˜ë¥¼ êµ¬í•˜ëŠ” í”„ë¡œê·¸ë¨ì˜ Cairo assembly ì½”ë“œëŠ” ë‹¤ìŒê³¼ ê°™ìœ¼ë©°, ì£¼ì„ìœ¼ë¡œ ê° ë¼ì¸ì˜ ì„¤ëª…ê³¼ í•´ë‹¹ ë¼ì¸ì—ì„œì˜ pc, ap, memory functionì„ ë‚˜íƒ€ë‚´ì—ˆë‹¤.[ap] = 1; ap++[ap] = 1; ap++body:[ap] = [ap - 3] - 1; ap++[ap] = [ap - 2]; ap++[ap] = [ap - 3] + [ap - 4]; ap++ì¦‰ jë²ˆì§¸ í”¼ë³´ë‚˜ì¹˜ ìˆ˜ ê³„ì‚°ì´ ëë‚˜ì§€ ì•Šì•˜ë‹¤ë©´ bodyë¡œ ì í”„í•œë‹¤.\r\njmp body if [ap - 3] != 0end :\r\njmp end # ë¬´í•œë£¨í”„ìœ„ Cairo assembly ì½”ë“œê°€ ë™ì‘í•˜ëŠ” ê³¼ì •ì„ ì•„ë˜ì™€ ê°™ì´ ë„ì‹í™”í•  ìˆ˜ ìˆë‹¤. (í¸ì˜ìƒ pcë¥¼ ì œì™¸í•˜ê³  memory functionê³¼ ì§ì ‘ì ìœ¼ë¡œ ê´€ë ¨ìˆëŠ” apë§Œ ë„ì‹í™”í•˜ì˜€ë‹¤.)\r\nì˜ˆì‹œ ì½”ë“œì—ì„œì˜ jëŠ” m(ap_I -1) = j, ì¦‰ jë²ˆì§¸ í”¼ë³´ë‚˜ì¹˜ ìˆ˜ì—ì„œ jì— í•´ë‹¹í•œë‹¤.\r\nbody ë°˜ë³µë¬¸ì— ì§„ì…í•˜ê¸° ì „, ì²˜ìŒ ë‘ ë¼ì¸ì´ ì‹¤í–‰ë˜ë©´ (m(ap -3), m(ap -2), m(ap -1)) = (j, 1, 1)ì˜ ê°’ì„ ê°€ì§€ë©° bodyì— ì§„ì…í•œ í›„ ì„¸ ë¼ì¸ì´ ì‹¤í–‰ë˜ë©´ (j-1, 1, 2)ê°€ ëœë‹¤.\r\nì´í›„ (j-2, 2, 3)Â , (j-3, 3, 5), (j-4, 5, 8), (j-5, 8, 13)Â â€¦ ìˆœìœ¼ë¡œ (m(ap -3), m(ap -2), m(ap -1)) ê°’ì´ ë³€í™”í•˜ëŠ”ë°, ì´ë¥¼ ë³´ë©´ ê° ë‹¨ê³„ì—ì„œì˜ ê°’ì´ ê³§ (ê³„ì‚°ê¹Œì§€ ë‚¨ì€ ë‹¨ê³„, í”¼ë³´ë‚˜ì¹˜ ê³„ì‚°ì„ ìœ„í•œ ì²« ë²ˆì§¸ ìˆ˜, í”¼ë³´ë‚˜ì¹˜ ê³„ì‚°ì„ ìœ„í•œ ë‘ ë²ˆì§¸ ìˆ˜) ì„ì„ ì•Œ ìˆ˜ ìˆë‹¤.\r\nì•„ë˜ ê·¸ë¦¼ì€ í”¼ë³´ë‚˜ì¹˜ ìˆ˜ì—´ì´ (1, 1, 2, 3) ê¹Œì§€ ê³„ì‚°ëœ ìƒíƒœì—ì„œ 2 + 3 = 5ë¥¼ ê³„ì‚°í•˜ëŠ” ê³¼ì •(j = 7, (j-2, 2, 3) â‡’ (j-3, 3, 5))ì— í•´ë‹¹í•œë‹¤.\r\nCairo í”„ë¡œê·¸ë¨ì˜ ì¦ëª… ê³¼ì •Â : 2. CairoÂ Bytecode\r\nCairo assemblerê°€ í”„ë¡œê·¸ë¨ì„ Cairo ë°”ì´íŠ¸ì½”ë“œë¡œ ë³€í™˜í•˜ë©°, ì´ ë‹¨ê³„ëŠ” ì•ì„œ ì–¸ê¸‰í•œ 4ë‹¨ê³„ ì¤‘ 2ë‹¨ê³„ì— í•´ë‹¹í•œë‹¤.\r\nê³„ì‚°ì„ ìœ„í•œ Cairo í”„ë¡œê·¸ë¨ì„ ì‘ì„±í•œë‹¤.\r\nì‘ì„±ëœ í”„ë¡œê·¸ë¨ì„ Cairo ë°”ì´íŠ¸ì½”ë“œë¡œ ë³€í™˜í•œë‹¤.\r\nCairo Runnerê°€ ë°”ì´íŠ¸ì½”ë“œë¥¼ ì‹¤í–‰í•˜ì—¬ execution trace S, partial memory function m*, full memory function mì„ ì–»ëŠ”ë‹¤.\r\nSTARK proverë¡œ ì•„ë˜ statementì— ëŒ€í•œ proofë¥¼ ìƒì„±í•œë‹¤.\"nondeterministic Cairo machineì€ inputì´ ( T, m*, pcI, pc_F, ap_I, ap_F )ì¼ ë•Œ accept í•œë‹¤.\"\r\nCairo ë°”ì´íŠ¸ì½”ë“œëŠ” ì•„ë˜ ìš”ì†Œë“¤ë¡œ êµ¬ì„±ë˜ì–´ ìˆë‹¤.\r\nfield element bì˜ sequence, ì¦‰ b = (b0,Â â€¦Â , b{|b|-1})\r\në‘ ê°œì˜ indexì¸ prog_start, prog_endCairo ë°”ì´íŠ¸ì½”ë“œì—ëŠ” í”„ë¡œê·¸ë¨ì„ ì‹¤í–‰í•˜ê¸° ìœ„í•´ í•„ìš”í•œ ì •ë³´ê°€ ë“¤ì–´ìˆìœ¼ë©°, í”„ë¡œê·¸ë¨ì„ ì‹¤í–‰í•˜ê³  ì‹¶ë‹¤ë©´ ë©”ëª¨ë¦¬ ì£¼ì†Œì˜ ê¸°ë³¸ê°’ì¸ pr(program base)ë¥¼ ê³ ë¥¸ í›„ ì´ì— ë§ê²Œ partial memory function mê³¼ pc_I, pc_Fë¥¼ ì„¤ì •í•œë‹¤. ì´ëŠ” í”„ë¡œê·¸ë¨ì„ ì‹¤í–‰í•  ë•Œ í•„ìš”í•œ ë©”ëª¨ë¦¬ì˜ ë²”ìœ„ë§Œ ìˆë‹¤ë©´ ì„ì˜ì˜ ì£¼ì†Œë¥¼ ì„ íƒí•´ í•´ë‹¹ ì£¼ì†Œë¶€í„° ì‹œì‘í•˜ì—¬ ì‚¬ìš©í•  ìˆ˜ ìˆê²Œ í•˜ê¸° ìœ„í•¨ì´ë‹¤.\r\npartial memory function m ì€ m*(progbase + i) = b_i, (i ëŠ” [0, |b|])ë¡œ ì„¤ì •ë˜ë©°, pc_Iì™€ pc_FëŠ” ê°ê° pc_I = prog_base + prog_start, pc_F = prog_base + prog_endë¡œ ì„¤ì •ëœë‹¤. ì¦‰ |b|ê°œì˜ elementì¸ b = ( b0Â ,Â â€¦Â , b{|b| -1})ëŠ” prog_baseë¶€í„° prog_base + |b| ì— í•´ë‹¹í•˜ëŠ” ì£¼ì†Œì˜ ë©”ëª¨ë¦¬ ê°’ì´ë‹¤.\r\nìœ„ í”¼ë³´ë‚˜ì¹˜ í”„ë¡œê·¸ë¨ì—ì„œ ì•„ë˜ì™€ ê°™ì€ ë°”ì´íŠ¸ì½”ë“œë¥¼ ì–»ì„ ìˆ˜ ìˆë‹¤.\r\nì¶œì²˜Â : Cairo whitepaperprog_baseë¥¼ 0ì´ë¼ ê°€ì •í•˜ë©´,\r\nì´ ë°”ì´íŠ¸ì½”ë“œì— ì˜í•´ partial memory functionì€ m*(0) = 0x480680017fff8000, m*(1) = 1, m*(2) = 0x480680017fff8000,Â â€¦ ì™€ ê°™ì´ ì„¤ì •ëœë‹¤. pcê°’ì€ pcI = 0 + 0, pc_F = 0 + 10ë¡œ ì„¤ì •ëœë‹¤.\r\nì‹¤ì œë¡œ ìœ„ í”¼ë³´ë‚˜ì¹˜ ì½”ë“œë¥¼ ì»´íŒŒì¼í–ˆì„ ë•Œ ì•„ë˜ì™€ ê°™ì€ ë°”ì´íŠ¸ì½”ë“œë¥¼ ì–»ì—ˆë‹¤. data ê°€ b = ( b0Â ,Â ...Â , b{|b| - 1})ì— í•´ë‹¹í•œë‹¤.\r\nì»´íŒŒì¼ëœ fib-compiled.json íŒŒì¼Cairo í”„ë¡œê·¸ë¨ì˜ ì¦ëª… ê³¼ì •Â : 3. Cairo RunnerÂ ì‹¤í–‰\r\nCairo RunnerëŠ” ì»´íŒŒì¼ëœ Cairo í”„ë¡œê·¸ë¨(ìœ„ì™€ ê°™ì€ ë°”ì´íŠ¸ì½”ë“œ)ì„ ì‹¤í–‰í•˜ëŠ” í”„ë¡œê·¸ë¨ì´ë‹¤. Cairo Runnerë¥¼ í†µí•´ í”„ë¡œê·¸ë¨ì„ ì‹¤í–‰í•˜ëŠ” ê²ƒì´ ì„¸ ë²ˆì§¸ ë‹¨ê³„ì— í•´ë‹¹í•˜ë©°, ì‹¤í–‰í•œ í›„ proof ìƒì„±ì— í•„ìš”í•œ ê°’ë“¤ì„ ì–»ì„ ìˆ˜ ìˆë‹¤.\r\nê³„ì‚°ì„ ìœ„í•œ Cairo í”„ë¡œê·¸ë¨ì„ ì‘ì„±í•œë‹¤.\r\nì‘ì„±ëœ í”„ë¡œê·¸ë¨ì„ Cairo ë°”ì´íŠ¸ì½”ë“œë¡œ ë³€í™˜í•œë‹¤.\r\nCairo Runnerê°€ ë°”ì´íŠ¸ì½”ë“œë¥¼ ì‹¤í–‰í•˜ì—¬ execution trace S, partial memory function m*, full memory function mì„ ì–»ëŠ”ë‹¤.\r\nSTARK proverë¡œ ì•„ë˜ statementì— ëŒ€í•œ proofë¥¼ ìƒì„±í•œë‹¤.\"nondeterministic Cairo machineì€ inputì´ ( T, m*, pc_I, pc_F, ap_I, ap_F )ì¼ ë•Œ accept í•œë‹¤.\"\r\nCairo RunnerëŠ” ì»´íŒŒì¼ëœ ë°”ì´íŠ¸ì½”ë“œë¥¼ ì‹¤í–‰í•˜ë©° execution trace, partial memory functionê³¼ full memory functionì„ ì–»ëŠ”ë‹¤. ì—¬ê¸°ì„œ execution traceëŠ” ìœ„ì—ì„œ ì–¸ê¸‰í–ˆë“¯ì´ pc, ap, fp ë ˆì§€ìŠ¤í„° ê°’ì´ë©°, partial memory function, full memory functionì€ í”„ë¡œê·¸ë¨ì´ ì‹¤í–‰ë˜ë©´ì„œ ì‚¬ìš©ëœ ë©”ëª¨ë¦¬ ê°’ë“¤ì— í•´ë‹¹í•œë‹¤.\r\nCairo Runnerì˜ ì†ŒìŠ¤ ì½”ë“œëŠ” í˜„ì¬ ìŠ¤íƒ€í¬ì›¨ì–´ ê¹ƒí—™ì— ê³µê°œë˜ì–´ ìˆìœ¼ë©° (https://github.com/starkware-libs/cairo-lang), ì•„ë˜ ì½”ë“œëŠ” Cairo Runner ì†ŒìŠ¤ ì½”ë“œ ì¤‘ ì»´íŒŒì¼ëœ json íŒŒì¼ì—ì„œ trace(pc, ap, fp)ë¥¼ ê¸°ë¡í•˜ëŠ” ë¶€ë¶„ì— í•´ë‹¹í•œë‹¤.\r\nclass CairoRunner:\r\ndef init(\r\nself,\r\nprogram: ProgramBase,\r\nlayout: str = \"plain\",\r\nmemory: MemoryDict = None,\r\nproof_mode: Optional[bool] = None,\r\nallow_missing_builtins: Optional[bool] = None,\r\n):\r\nself.program = program\r\nself.layout = layout\r\nself.builtin_runners: Dict[str, BuiltinRunner] = {}\r\nself.original_steps = None\r\nself.proof_mode = False if proof_mode is None else proof_mode\r\nself.allow_missing_builtins = (\r\nFalse if allow_missing_builtins is None else allow_missing_builtins\r\n)\r\n...\r\ndef relocate(self):\r\nself.segment_offsets = self.segments.relocate_segments()\r\nself.relocated_memory = MemoryDict(\r\n{\r\nself.relocate_value(addr): self.relocate_value(value)\r\nfor addr, value in self.vm_memory.items()\r\n}\r\n)\r\nself.relocated_trace = relocate_trace(\r\nself.vm.trace, self.segment_offsets, self.program.prime\r\n)\r\nfor builtin_runner in self.builtin_runners.values():\r\nbuiltin_runner.relocate(self.relocate_value)\r\nCairo Runner í´ë˜ìŠ¤ì˜ ë©”ì„œë“œì¸ relocate ëŠ” relocate_trace ë©”ì„œë“œë¥¼ í†µí•´ í•˜ë‚˜ì˜ instructionì„ ì‹¤í–‰í•˜ë©´ì„œ self.relocated_traceë¥¼ ì—…ë°ì´íŠ¸í•œë‹¤.\r\nrelocate_trace ë©”ì„œë“œëŠ” í˜„ì¬ê¹Œì§€ì˜ traceì™€ instruction ì •ë³´ë¥¼ ë°›ì•„ ìƒˆë¡œìš´ pc, ap, fp ê°’ì„ traceì— ì¶”ê°€í•˜ì—¬ ë°˜í™˜í•œë‹¤.\r\ndef relocate_trace(\r\ntrace: List[TraceEntry[MaybeRelocatable]],\r\nsegment_offsets: Dict[int, T],\r\nprime: int,\r\nallow_missing_segments: bool = False,\r\n) -> List[TraceEntry[T]]:\r\nnew_trace: List[TraceEntry[T]] = []\r\ndef relocate_val(x):\r\nreturn relocate_value(x, segment_offsets, prime, allow_missing_segments)\r\nfor entry in trace:\r\nnew_trace.append(\r\nTraceEntry(\r\npc=relocate_val(entry.pc),\r\nap=relocate_val(entry.ap),\r\nfp=relocate_val(entry.fp),\r\n)\r\n)\r\nreturn new_trace\r\nCairo í”„ë¡œê·¸ë¨ì˜ ì¦ëª… ê³¼ì •Â : 4. STARK proofÂ ìƒì„±\r\nCairo Runnerê°€ í”„ë¡œê·¸ë¨ì„ ì‹¤í–‰í•˜ì—¬ execution traceë¥¼ í¬í•¨í•œ outputì„ ë°˜í™˜í–ˆë‹¤ë©´, ì´ì œ proofì˜ ì¬ë£Œê°€ ë  statementë¥¼ ì‘ì„±í•  ìˆ˜ ìˆë‹¤. STARK prover (StarkEx ì„œë¹„ìŠ¤ë“¤ì€ SHARPâ€Š-â€Šshared proverë¥¼ ì‚¬ìš©í•œë‹¤.)ê°€ statementì— ëŒ€í•œ proofë¥¼ ë§Œë“¤ê²Œ ë˜ë©°, ì´ ê³¼ì •ì´ Cairoë¥¼ í†µí•œ proof ìƒì„±ì˜ ë§ˆì§€ë§‰ ë‹¨ê³„ì— í•´ë‹¹í•œë‹¤.\r\nê³„ì‚°ì„ ìœ„í•œ Cairo í”„ë¡œê·¸ë¨ì„ ì‘ì„±í•œë‹¤.\r\nì‘ì„±ëœ í”„ë¡œê·¸ë¨ì„ Cairo ë°”ì´íŠ¸ì½”ë“œë¡œ ë³€í™˜í•œë‹¤.\r\nCairo Runnerê°€ ë°”ì´íŠ¸ì½”ë“œë¥¼ ì‹¤í–‰í•˜ì—¬ execution trace S, partial memory function m*, full memory function mì„ ì–»ëŠ”ë‹¤.\r\nSTARK proverë¡œ ì•„ë˜ statementì— ëŒ€í•œ proofë¥¼ ìƒì„±í•œë‹¤.\"nondeterministic Cairo machineì€ inputì´ ( T, m*, pc_I, pc_F, ap_I, ap_F )ì¼ ë•Œ accept í•œë‹¤.\"\r\në¨¼ì € ìŠ¤íƒ€í¬ì›¨ì–´ê°€ ì œì‹œí•œ deterministic Cairo machineê³¼ nondeterministic Cairo machineì˜ ê°œë…ì„ ì‚´í´ë³´ì.\r\n(ìˆ˜ì‹ì„ ë‹´ê¸° ìœ„í•´ ê°œë… ë‚´ìš©ì€ ë³„ë„ë¡œ ì •ë¦¬í•œ notion í˜ì´ì§€ì˜ ë‚´ìš©ì„ ì‚¬ìš©)\r\nproofë¡œ ë§Œë“¤ê³ ì í•˜ëŠ” statementë¥¼ ë‹¤ì‹œ ì‚´í´ë³´ì.\r\n\"nondeterministic Cairo machineì€ inputì´ ( T, m*, pc_I, pc_F, ap_I, ap_F )ì¼ ë•Œ accept í•œë‹¤.\"\r\nì´ statementê°€ ì„±ë¦½í•œë‹¤ë©´, ì¦‰ nondeterministic Cairo machineì´ ( T, m*, pc_I, pc_F, ap_I, ap_F )ì„ accept í•œë‹¤ë©´ deterministic Cairo machineì´ accept í•˜ëŠ” inputì¸ ( T, m, S )ê°€ ì¡´ì¬í•¨ì„ ë‚˜íƒ€ë‚¸ë‹¤.\r\nì¦ëª…ì€ ë‹¤ìŒê³¼ ê°™ë‹¤.\r\nmì€ m*ì„ í™•ì¥í•˜ê¸° ë•Œë¬¸ì—, m*ì´ í¬í•¨í•˜ëŠ” Cairo í”„ë¡œê·¸ë¨(í¸ì˜ìƒ í”¼ë³´ë‚˜ì¹˜ í”„ë¡œê·¸ë¨)ì˜ ë°”ì´íŠ¸ì½”ë“œëŠ” mì— í¬í•¨ëœë‹¤. ë”°ë¼ì„œ í”„ë¡œê·¸ë¨ì˜ ëª¨ë“  stepì— ëŒ€í•´ memory functionì„ í™•ì¸í•  ìˆ˜ ìˆë‹¤.\r\npc_I = prog_base + prog_startì´ê¸° ë•Œë¬¸ì— deterministic Cairo machineì´ ì‹¤í–‰í•˜ëŠ” ì²« instructionì€ í”¼ë³´ë‚˜ì¹˜ í”„ë¡œê·¸ë¨ì˜ ì²« instructionì´ë‹¤.\r\nTê°œì˜ stepë™ì•ˆ ë™ì¼í•˜ê²Œ ì‹¤í–‰ëœë‹¤.\r\npc_F = prog_base + prog_endì´ê¸° ë•Œë¬¸ì—, í”¼ë³´ë‚˜ì¹˜ í”„ë¡œê·¸ë¨ì˜ ë§ˆì§€ë§‰ instruction ì‹¤í–‰ì„ í™•ì¸í•  ìˆ˜ ìˆë‹¤.ê²°ë¡ ì ìœ¼ë¡œ deterministic Cairo machineì˜ outputì´ accept ë¼ë©´, ê° stepë§ˆë‹¤ state (pc, ap, fp) transitionì´ ëª¨ë‘ validí•¨ì„ ë‚˜íƒ€ë‚´ë©° ì´ëŠ” Cairoë¡œ ì‘ì„±ëœ í”„ë¡œê·¸ë¨ ì—°ì‚°ì˜ ìœ íš¨ì„±ì„ ë³´ì¥í•œë‹¤.\r\nì´ ì—°ì‚°ì˜ ìœ íš¨ì„±ì„ ì¦ëª…í•´ì¤„ proofê°€ ë§Œë“¤ì–´ì§€ë©´ ì´ëŠ” ì˜¨ì²´ì¸ì˜ SHARP ì»¨íŠ¸ë™íŠ¸ë¡œ ì „ë‹¬ëœë‹¤. í˜„ì¬ SHARP ì»¨íŠ¸ë™íŠ¸ëŠ” ì´ë”ë¦¬ì›€ goerli í…ŒìŠ¤íŠ¸ë„·(https://goerli.etherscan.io/address/0xAB43bA48c9edF4C2C4bB01237348D1D7B28ef168#readContract) ì— ë°°í¬ë˜ì–´ ìˆë‹¤.\r\nSHARP ì»¨íŠ¸ë™íŠ¸ëŠ” Fact Registryë¼ëŠ” ì»¨íŠ¸ë™íŠ¸ì— factë¼ëŠ” ì´ë¦„ìœ¼ë¡œ ì¦ëª…(proof)ì„ ì‘ì„±í•˜ì—¬ ì €ì¥í•œë‹¤. ì¦ëª…ì´ ë§Œë“¤ì–´ì¡Œìœ¼ë‹ˆ ì´ë¥¼ ê²€ì¦í•´ì•¼ í•˜ê³ , ì´ ì—­í• ì€ ì¶”í›„ ì„¤ëª…í•  Verifier Contractê°€ ë‹´ë‹¹í•˜ê²Œ ëœë‹¤.\r\nì´ factê°€ ì˜¨ì²´ì¸ì— ë“±ë¡ë˜ì—ˆìœ¼ë¯€ë¡œ Verifier ContractëŠ” ìœ íš¨ì„± ê²€ì¦ì„ ìœ„í•´ ì´ë¥¼ ì‚¬ìš©í•  ìˆ˜ ìˆë‹¤. Verify Contractì˜ ê²€ì¦ ë¡œì§ì€ ì´í›„ ì‹œë¦¬ì¦ˆì—ì„œ ë‹¤ë£¨ê¸°ë¡œ í•œë‹¤.\r\në§ºìŒë§\r\nìŠ¤íƒ€í¬ì›¨ì–´ëŠ” ë²”ìš©ì ì¸ ì¦ëª…ì˜ ìƒì„±ê³¼ ê²€ì¦ì„ ìœ„í•´ Cairo ì–¸ì–´ë¥¼ ê°œë°œí•˜ì˜€ë‹¤. ì´ ì–¸ì–´ê°€ ì–´ë–»ê²Œ í”„ë¡œê·¸ë¨ì˜ ìœ íš¨ì„±ì„ ì¦ëª…í•˜ëŠ”ì§€ ì‚´í´ë³´ì•˜ê³ , ê²°êµ­ í•µì‹¬ì€ ë©”ëª¨ë¦¬ì˜ ë¶ˆë³€ì„±ì„ ê¸°ë°˜ìœ¼ë¡œ (pc, ap, fp)ì˜ state transitionì„ í†µí•´ í”„ë¡œê·¸ë¨ì˜ ìœ íš¨ì„±ì„ ì¦ëª…í•˜ëŠ” ê²ƒì´ì—ˆë‹¤. í”„ë¡œê·¸ë¨ì„ ì‹¤í–‰í•˜ëŠ” ê²ƒë§Œìœ¼ë¡œë„ ìœ íš¨ì„±ì„ ì¦ëª…í•  ìˆ˜ ìˆë‹¤ëŠ” ê²ƒ, ë˜í•œ ê·¸ ì¦ëª… ê³¼ì •ì—ì„œ í•„ìš”í•œ ì—°ì‚°ì„ ìµœì†Œí™”í–ˆë‹¤ëŠ” ê²ƒì€ ë¶„ëª… L2 ë„¤íŠ¸ì›Œí¬ì—ì„œ ì§€ì†ê°€ëŠ¥í•œ í™•ì¥ì„±ì„ êµ¬í˜„í•˜ëŠ” ë°ì— ì¼ì¡°í•œë‹¤. ê·¸ëŸ¬ë‚˜ ì•„ì§ StarkExì— ì°¸ì—¬í•˜ëŠ” í”„ë¡œì íŠ¸ë“¤ (dydx, Immutable X, Sorare, DeverseFi)ì˜ Cairoë¡œ ì‘ì„±ëœ ë¹„ì¦ˆë‹ˆìŠ¤ ë¡œì§ì´ ì•„ì§ê¹Œì§€ ì˜¤í”ˆì†ŒìŠ¤ë¡œì„œ ê³µê°œëœ ì‚¬í•­ì€ ì—†ìœ¼ë©°, ì´ìƒì ì¸ ìŠ¤íƒ€í¬ì›¨ì–´ ìƒíƒœê³„ë¥¼ ìœ„í•´ì„œëŠ” Cairoì˜ ì ìš©ì´ ë”ìš± í™•ëŒ€ë˜ì–´ì•¼ í•œë‹¤. ì´ë¥¼ ìœ„í•´ ë³¸ ê²Œì‹œê¸€ì€ Cairoì— ëŒ€í•œ ì•„ì£¼ ê¸°ë³¸ì ì¸ ì´í•´ë¥¼ ë•ê³  ìˆë‹¤.\r\në‚´ìš© í”¼ë“œë°±ê³¼ ì¶”ê°€ì ì¸ ì§ˆë¬¸ì€ ì•„ë˜ ì—°ë½ì²˜ë¡œ ë¶€íƒë“œë¦½ë‹ˆë‹¤.\r\nemailÂ : lhm0710@snu.ac.kr\r\nReference\r\n[1] Lior Goldberg, Shahar Papini, and Michael Riabzev, \"Cairoâ€Š-â€Ša Turing-complete STARK-friendly CPU architecture\", 2021"}},"/":{"title":"About","data":{"hyemin-lee#Hyemin Lee":"Hi, I'm Hyemin Lee! ğŸ‘‹\nI enjoy solving problems and thinking logically, which naturally led me to work as a software engineer. I'm an adventurous individual who also has a passion for photography and travel.I'm currently interested in CRDT, Zero knowledge proof and distributed system.","work-experience#Work Experience":"","naver-corp-seoul-republic-of-korea#NAVER Corp. (Seoul, Republic of Korea)":"Software Engineer Intern (Jul 2023 - Sep 2023)\nCRDT(Conflict-free replicated data type) Development: Contributed to Yorkie, a document store for collaborative application by developing the software algorithm of multi-user undo and redo feature (issue#652).\nSkills: Go, Typescript, MongoDB, Docker","radius-lab-seoul-republic-of-korea#Radius Lab (Seoul, Republic of Korea)":"Software Engineer (Jan 2022 - Jun 2023)\nPVDE(Practical Verifiable Delay Encryption) implementation: Proposed and implemented PVDE, which was selected for the Ethereum Foundationâ€™s grant program and received $1.7M investment led by Hashed.\nSkills: Rust, Actix-web, Express.js, Docker\n360 DEX Development: Developed 360 DEX interface page and PVDE WASM package for interface. Optimized PVDE execution time by 85% by enabling browser multi-threading with web worker.\nSkills: React.js, WASM, Web worker","hanhwa-life-insurance-co-ltd-seoul-republic-of-korea#Hanhwa Life Insurance co., ltd (Seoul, Republic of Korea)":"Research Assistant Intern (Jun 2021 - Aug 2021)\nBlockchain Research: Published 10+ research papers about blockchain infrastructure and DeFi(AMM) which was used as a learning resource for 2,500+ employees.","elysia-dao-llc-seoul-republic-of-korea#Elysia DAO LLC. (Seoul, Republic of Korea)":"Mobile Application Engineer Intern (Aug 2020 - Feb 2021)\nMobile App Development: Developed Elysia mobile application which have 5,000+ downloads.\nSkills: React.js, React Native, Docker, AWS","education#Education":"","seoul-national-university-seoul-republic-of-korea#Seoul National University (Seoul, Republic of Korea)":"B.S in Rural Systems Engineering (Mar 2017 - Aug 2023)\nB.S in Computer Science and Engineering (Mar 2017 - Aug 2023)\nOutstanding Thesis Award (ìš°ìˆ˜í•™ì‚¬ ë…¼ë¬¸ë°œí‘œìƒ), Aug 2023\nB.A in Information Science and Culture (Mar 2017 - Aug 2023)","contacts#Contacts":"GitHub @hyemmie\nMedium @Hyem_mie\nEmail lhm07100@gmail.com"}},"/posts/markdown":{"title":"Markdown Examples","data":{"h2-heading#h2 Heading":"","h3-heading#h3 Heading":"","h4-heading#h4 Heading":"","h5-heading#h5 Heading":"","h6-heading#h6 Heading":"","emphasis#Emphasis":"This is bold textThis is italic textStrikethrough","blockquotes#Blockquotes":"Develop. Preview. Ship. â€“ Vercel","lists#Lists":"Unordered\nLorem ipsum dolor sit amet\nConsectetur adipiscing elit\nInteger molestie lorem at massa\nOrdered\nLorem ipsum dolor sit amet\nConsectetur adipiscing elit\nInteger molestie lorem at massa","code#Code":"Inline code\nexport default function Nextra({ Component, pageProps }) {\n  return (\n    <>\n      <Head>\n        <link\n          rel=\"alternate\"\n          type=\"application/rss+xml\"\n          title=\"RSS\"\n          href=\"/feed.xml\"\n        />\n        <link\n          rel=\"preload\"\n          href=\"/fonts/Inter-roman.latin.var.woff2\"\n          as=\"font\"\n          type=\"font/woff2\"\n          crossOrigin=\"anonymous\"\n        />\n      </Head>\n      <Component {...pageProps} />\n    </>\n  )\n}","tables#Tables":"Option\tDescription\tFirst\tLorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua.\tSecond\tLorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua.\tThird\tLorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua.","links#Links":"Next.js\nNextra\nVercel","footnotes#Footnotes":"Footnote .\nFootnote .\nFootnote can have markupand multiple paragraphs.Footnote text."}},"/photos/hok":{"title":"Hokkaido","data":{"":"Hokkaido!"}},"/posts":{"title":"Posts","data":{}},"/photos":{"title":"Photos","data":{"":"Here's some of my photography. All photos are taken by Sony A7C and Leica mini zoom.","hokkaido#Hokkaido":"","tel-aviv#Tel Aviv":""}},"/projects":{"title":"Projects","data":{"business-projects#Business Projects":"Projects I've worked on at company","individual-projects#Individual Projects":"Projects I've worked on individually","cs-courses-projects#CS Courses Projects":"Projects I've worked on at university"}},"/tags/[tag]":{"title":"Tagged Posts","data":{}},"/posts/pages":{"title":"Next.js Pages","data":{"":"In Next.js, a page is a React Component exported from a .js, .jsx, .ts, or .tsx file in the pages directory. Each page is associated with a route based on its file name.Example: If you create pages/about.js that exports a React component like below, it will be accessible at /about.\nfunction About() {\n  return <div>About</div>\n}\nexport default About","pages-with-dynamic-routes#Pages with Dynamic Routes":"Next.js supports pages with dynamic routes. For example, if you create a file called pages/posts/[id].js, then it will be accessible at posts/1, posts/2, etc.\nTo learn more about dynamic routing, check the Dynamic Routing documentation.","pre-rendering#Pre-rendering":"By default, Next.js pre-renders every page. This means that Next.js generates HTML for each page in advance, instead of having it all done by client-side JavaScript. Pre-rendering can result in better performance and SEO.Each generated HTML is associated with minimal JavaScript code necessary for that page. When a page is loaded by the browser, its JavaScript code runs and makes the page fully interactive. (This process is called hydration.)","two-forms-of-pre-rendering#Two forms of Pre-rendering":"Next.js has two forms of pre-rendering: Static Generation and Server-side Rendering. The difference is in when it generates the HTML for a page.\nStatic Generation (Recommended): The HTML is generated at build time and will be reused on each request.\nServer-side Rendering: The HTML is generated on each request.\nImportantly, Next.js lets you choose which pre-rendering form you'd like to use for each page. You can create a \"hybrid\" Next.js app by using Static Generation for most pages and using Server-side Rendering for others.We recommend using Static Generation over Server-side Rendering for performance reasons. Statically generated pages can be cached by CDN with no extra configuration to boost performance. However, in some cases, Server-side Rendering might be the only option.You can also use Client-side Rendering along with Static Generation or Server-side Rendering. That means some parts of a page can be rendered entirely by client side JavaScript. To learn more, take a look at the Data Fetching documentation.","static-generation-recommended#Static Generation (Recommended)":"If a page uses Static Generation, the page HTML is generated at build time. That means in production, the page HTML is generated when you run next build . This HTML will then be reused on each request. It can be cached by a CDN.In Next.js, you can statically generate pages with or without data. Let's take a look at each case.","static-generation-without-data#Static Generation without data":"By default, Next.js pre-renders pages using Static Generation without fetching data. Here's an example:\nfunction About() {\n  return <div>About</div>\n}\nexport default About\nNote that this page does not need to fetch any external data to be pre-rendered. In cases like this, Next.js generates a single HTML file per page during build time.","static-generation-with-data#Static Generation with data":"Some pages require fetching external data for pre-rendering. There are two scenarios, and one or both might apply. In each case, you can use a special function Next.js provides:\nYour page content depends on external data: Use getStaticProps.\nYour page paths depend on external data: Use getStaticPaths (usually in addition to getStaticProps).","scenario-1-your-page-content-depends-on-external-data#Scenario 1: Your page content depends on external data":"Example: Your blog page might need to fetch the list of blog posts from a CMS (content management system).\n// TODO: Need to fetch `posts` (by calling some API endpoint)\n//       before this page can be pre-rendered.\nfunction Blog({ posts }) {\n  return (\n    <ul>\n      {posts.map((post) => (\n        <li>{post.title}</li>\n      ))}\n    </ul>\n  )\n}\nexport default Blog\nTo fetch this data on pre-render, Next.js allows you to export an async function called getStaticProps from the same file. This function gets called at build time and lets you pass fetched data to the page's props on pre-render.\nfunction Blog({ posts }) {\n  // Render posts...\n}\n// This function gets called at build time\nexport async function getStaticProps() {\n  // Call an external API endpoint to get posts\n  const res = await fetch('https://.../posts')\n  const posts = await res.json()\n  // By returning { props: { posts } }, the Blog component\n  // will receive `posts` as a prop at build time\n  return {\n    props: {\n      posts\n    }\n  }\n}\nexport default Blog\nTo learn more about how getStaticProps works, check out the Data Fetching documentation.","scenario-2-your-page-paths-depend-on-external-data#Scenario 2: Your page paths depend on external data":"Next.js allows you to create pages with dynamic routes. For example, you can create a file called pages/posts/[id].js to show a single blog post based on id. This will allow you to show a blog post with id: 1 when you access posts/1.\nTo learn more about dynamic routing, check the Dynamic Routing documentation.\nHowever, which id you want to pre-render at build time might depend on external data.Example: suppose that you've only added one blog post (with id: 1) to the database. In this case, you'd only want to pre-render posts/1 at build time.Later, you might add the second post with id: 2. Then you'd want to pre-render posts/2 as well.So your page paths that are pre-rendered depend on external data**.** To handle this, Next.js lets you export an async function called getStaticPaths from a dynamic page (pages/posts/[id].js in this case). This function gets called at build time and lets you specify which paths you want to pre-render.\n// This function gets called at build time\nexport async function getStaticPaths() {\n  // Call an external API endpoint to get posts\n  const res = await fetch('https://.../posts')\n  const posts = await res.json()\n  // Get the paths we want to pre-render based on posts\n  const paths = posts.map((post) => ({\n    params: { id: post.id }\n  }))\n  // We'll pre-render only these paths at build time.\n  // { fallback: false } means other routes should 404.\n  return { paths, fallback: false }\n}\nAlso in pages/posts/[id].js, you need to export getStaticProps so that you can fetch the data about the post with this id and use it to pre-render the page:\nfunction Post({ post }) {\n  // Render post...\n}\nexport async function getStaticPaths() {\n  // ...\n}\n// This also gets called at build time\nexport async function getStaticProps({ params }) {\n  // params contains the post `id`.\n  // If the route is like /posts/1, then params.id is 1\n  const res = await fetch(`https://.../posts/${params.id}`)\n  const post = await res.json()\n  // Pass post data to the page via props\n  return { props: { post } }\n}\nexport default Post\nTo learn more about how getStaticPaths works, check out the Data Fetching documentation.","when-should-i-use-static-generation#When should I use Static Generation?":"We recommend using Static Generation (with and without data) whenever possible because your page can be built once and served by CDN, which makes it much faster than having a server render the page on every request.You can use Static Generation for many types of pages, including:\nMarketing pages\nBlog posts\nE-commerce product listings\nHelp and documentation\nYou should ask yourself: \"Can I pre-render this page ahead of a user's request?\" If the answer is yes, then you should choose Static Generation.On the other hand, Static Generation is not a good idea if you cannot pre-render a page ahead of a user's request. Maybe your page shows frequently updated data, and the page content changes on every request.In cases like this, you can do one of the following:\nUse Static Generation with Client-side Rendering: You can skip pre-rendering some parts of a page and then use client-side JavaScript to populate them. To learn more about this approach, check out the Data Fetching documentation.\nUse Server-Side Rendering: Next.js pre-renders a page on each request. It will be slower because the page cannot be cached by a CDN, but the pre-rendered page will always be up-to-date. We'll talk about this approach below.","server-side-rendering#Server-side Rendering":"Also referred to as \"SSR\" or \"Dynamic Rendering\".\nIf a page uses Server-side Rendering, the page HTML is generated on each request.To use Server-side Rendering for a page, you need to export an async function called getServerSideProps. This function will be called by the server on every request.For example, suppose that your page needs to pre-render frequently updated data (fetched from an external API). You can write getServerSideProps which fetches this data and passes it to Page like below:\nfunction Page({ data }) {\n  // Render data...\n}\n// This gets called on every request\nexport async function getServerSideProps() {\n  // Fetch data from external API\n  const res = await fetch(`https://.../data`)\n  const data = await res.json()\n  // Pass data to the page via props\n  return { props: { data } }\n}\nexport default Page\nAs you can see, getServerSideProps is similar to getStaticProps, but the difference is that getServerSideProps is run on every request instead of on build time.To learn more about how getServerSideProps works, check out our Data Fetching documentation","summary#Summary":"We've discussed two forms of pre-rendering for Next.js.\nStatic Generation (Recommended): The HTML is generated at build time and will be reused on each request. To make a page use Static Generation, either export the page component, or export getStaticProps (and getStaticPaths if necessary). It's great for pages that can be pre-rendered ahead of a user's request. You can also use it with Client-side Rendering to bring in additional data.\nServer-side Rendering: The HTML is generated on each request. To make a page use Server-side Rendering, export getServerSideProps. Because Server-side Rendering results in slower performance than Static Generation, use this only if absolutely necessary."}}}