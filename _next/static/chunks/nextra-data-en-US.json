{"/posts/Cairo":{"title":"StarkWare의 Cairo 언어가 프로그램의 유효성을 증명하는 방법","data":{"":"[StarkWare series] Cairo가 프로그램의 유효성을 증명하는 방법\r\nTL;DR\r\n본 게시글에서는 스타크웨어 생태계에서 한 축을 담당하고 있는 프로그래밍 언어 Cairo에 대해 살펴본다. Cairo는 증명 가능한 프로그램을 작성하기 위해 개발된 언어이며, 이를 구현하기 위해 CPU 아키텍처가 제안되었다. 이 Cairo 아키텍처를 통해 어떻게 프로그램의 유효성을 검증하는지 그 과정을 살펴보도록 한다. 본 게시글은 Cairo Whitepaper : \"Cairo - a Turing-complete STARK-friendly CPU architecture\" 기반으로 작성되었으며, 구독자가. 컴퓨터 아키텍처에 대한 기본적인 지식(폰 노이만 구조, 레지스터, 메모리, instruction 등)을 갖추고 있다고 가정하였다.\r\n용어 정리\r\nProver : '이 계산이 무결하다'는 것을 증명하고 싶은 참여자\r\nVerifier : 계산의 무결성을 검증하고 싶은 참여자\r\nProof : 유효한 계산의 증명\r\nInstruction : CPU가 작성된 프로그램을 수행하기 위해 실제로 동작하는 단위의 명령어\r\nCairo 프로그램 : Cairo 언어로 작성된 임의의 프로그램Cairo란?\r\n스타크웨어가 증명을 효율적으로 생성하고 검증하기 위해, 그리고 공통된 연산 과정을 사용하여 다양한 비즈니스 로직에 대한 증명을 생성하기 위해 Cairo라는 프로그래밍 언어 및 실행 환경 프로그램을 개발했다.\r\n다른 프로그래밍 언어와 달리 Cairo는 증명 가능한 프로그램을 작성하기 위해 개발되었고, 이를 위해 스타크웨어 팀은 Turing-complete STARK-friendly CPU architecture를 제안하였다.\r\nWe present Cairo, and efficient and practical von Neumann architecture that can be used with the STARK proof system to generate proofs of computational integrity (Cairo Whitepaper 1.2 Our contribution)\r\nCairo 프로그램의 검증 과정을 요약하자면 증명하고자 하는 프로그램을 Cairo로 작성한 후, 작성된 프로그램을 실행하면 execution trace를 얻을 수 있으며 prover는 이 trace를 통해 STARK proof를 만들 수 있다. 그리고 이 proof를 verifier가 검증하게 되는 구조이다.\r\n출처: https://www.cairo-lang.org/cairo-for-blockchain-developers/본 아티클에서는 trace가 어떻게 생성되는지, 이를 통해 어떻게 proof를 만들게 되는지 알아볼 것이다.\r\nCairo의 특징\r\n앞서 언급했던 Cairo의 디자인 목적은 다음과 같다.\r\n증명 가능한 statements로 쓰이는 프로그램을 쉽게 작성하고 읽기 위함\r\nSTARK proof system 기반으로 효율적인 증명을 생성하기 위함이 목적을 위한 Cairo 구현에서 핵심적인 특징은 바로 메모리 구조이다. Cairo 아키텍처에서는 \"Nondeterministic Continuous Read-Only Random-Access Memory\" 메모리 모델을 사용한다. 전통적인 Random-access read-write memory 모델에서는 instruction이 임의의 메모리 주소를 선택하고, 메모리 값을 읽거나 새로운 값을 쓰게 할 수 있다. 그러나 Nondeterministic Continuous Read-Only Random-Access Memory 모델에서는 메모리 값이 변하지 않고, 이미 값이 있는 주소의 경우 Cairo 프로그램은 메모리 값을 읽는 (read) 작업만 가능하다. 이를 통해 얻을 수 있는 이점은 다음과 같다.\r\nAIR 과정에서 필요한 값들을 메모리에 접근해서 가져오는 작업이 간단해진다.\r\nProver가 verifier에게 \"이 메모리 주소는 이 값을 가진다.\"라고 증명하는 작업이 간단해진다.Trace, State란 무엇인가? Cairo 프로그램이 실행되는 단계\r\n앞서 전체적인 개념을 설명하면서 Cairo 언어로 작성된 프로그램을 실행하면 trace를 얻을 수 있다고 했는데, 도대체 이 trace가 무엇이길래 Cairo로 작성된 프로그램의 증명을 가능하게 하는 것일까?\r\n결론부터 말하자면 trace는 프로그램을 실행하면서 사용한 메모리 주소의 나열이다. Cairo의 메모리 디자인 덕분에 메모리 값을 덮어쓸 수 없고, 이는 프로그램을 실행하면서 사용한 값이 유실되지 않음을 뜻한다.\r\nCairo 언어로 작성된 프로그램이 실행되는 과정은 아래와 같이 간단히 정리할 수 있으며, 자세한 내용은 [1]의 Chapter 3.5, 3.6에서 확인할 수 있다.\r\nCairo 프로그램의 증명 과정\r\n만약 \"피보나치 수열의 j번째 수는 y다\" 라는 문장을 증명하고 싶다면, 아래와 같은 과정을 거쳐야 한다.\r\n계산을 위한 Cairo 프로그램을 작성한다.\r\n작성된 프로그램을 Cairo 바이트코드로 변환한다.\r\nCairo Runner가 바이트코드를 실행하여 execution trace S, partial memory function m*, full memory function m을 얻는다.\r\nSTARK prover로 아래 statement에 대한 proof를 생성한다.\"nondeterministic Cairo machine은 input이 ( T, m*, pc_I, pc_F, ap_I, ap_F )일 때 accept 한다.\"\r\n위 statement에서 각 input이 의미하는 바는 다음과 같다.\r\nT : 실행한 프로그램의 연산 step 개수\r\nm* : 부분 메모리 함수\r\npc_I : 초기 pc 레지스터의 값\r\npc_F : 최종 pc 레지스터의 값\r\nap_I : 초기 ap레지스터의 값\r\nap_F : 최종 ap레지스터의 값앞서 Cairo 아키텍처는 Nondeterministic Continuous Read-Only Random-Access Memory 디자인을 사용한다고 했는데, 이러한 메모리 디자인 덕분에 하나의 instruction(쉽게 생각해서 코드 한 줄)이 실행될 때마다 이미 사용된 메모리의 값 확인(read)만 가능하도록 유지되며, write는 사용되지 않은 메모리에만 허용되므로 프로그램이 실행되면서 사용한 모든 메모리 값을 확인할 수 있다.\r\n따라서 프로그램의 실행 단계에서의 pc, ap, fp라는 특정 레지스터 값을 나열할 수 있고 이를 execution trace 라고 한다.\r\n보충 설명 : Cairo의 pc, ap, fp 레지스터\r\npc (program counter) : 현재 실행되는 instruction의 메모리 주소를 가리킨다.\r\nap (allocation pointer) : [convention] 아직 사용되지 않은 메모리 주소 중 첫 주소를 가리키며, 프로그래머가 다른 방향으로 쓸 수도 있다.\r\nfp (frame pointer) : 현재 function의 스택 메모리 시작점을 가리키는 레지스터(cf. RISC-V의 sp)로, 함수가 시작되면 ap와 같은 주소를 가리키다가 함수가 리턴되면 다시 이전에 가리키던 주소를 가리킨다.Cairo의 레지스터와 trace를 이해했다면, 다시 Cairo 프로그램의 증명 과정을 구체적으로 살펴보자.\r\nCairo 프로그램의 증명 과정 : 1. Cairo Program 작성\r\n하나의 Cairo program이 실행되는 과정을 이해하기 위해, 피보나치 프로그램을 예시로 살펴보자. 앞서 언급한 4단계의 과정 중 1단계에 해당한다.\r\n계산을 위한 Cairo 프로그램을 작성한다.\r\n작성된 프로그램을 Cairo 바이트코드로 변환한다.\r\nCairo Runner가 바이트코드를 실행하여 execution trace S, partial memory function m*, full memory function m을 얻는다.\r\nSTARK prover로 아래 statement에 대한 proof를 생성한다.\"nondeterministic Cairo machine은 input이 ( T, m*, pc_I, pc_F, ap_I, ap_F )일 때 accept 한다.\"\r\nj번째 피보나치 수를 구하는 프로그램의 Cairo assembly 코드는 다음과 같으며, 주석으로 각 라인의 설명과 해당 라인에서의 pc, ap, memory function을 나타내었다.[ap] = 1; ap++[ap] = 1; ap++body:[ap] = [ap - 3] - 1; ap++[ap] = [ap - 2]; ap++[ap] = [ap - 3] + [ap - 4]; ap++즉 j번째 피보나치 수 계산이 끝나지 않았다면 body로 점프한다.\r\njmp body if [ap - 3] != 0end :\r\njmp end # 무한루프위 Cairo assembly 코드가 동작하는 과정을 아래와 같이 도식화할 수 있다. (편의상 pc를 제외하고 memory function과 직접적으로 관련있는 ap만 도식화하였다.)\r\n예시 코드에서의 j는 m(ap_I -1) = j, 즉 j번째 피보나치 수에서 j에 해당한다.\r\nbody 반복문에 진입하기 전, 처음 두 라인이 실행되면 (m(ap -3), m(ap -2), m(ap -1)) = (j, 1, 1)의 값을 가지며 body에 진입한 후 세 라인이 실행되면 (j-1, 1, 2)가 된다.\r\n이후 (j-2, 2, 3) , (j-3, 3, 5), (j-4, 5, 8), (j-5, 8, 13) … 순으로 (m(ap -3), m(ap -2), m(ap -1)) 값이 변화하는데, 이를 보면 각 단계에서의 값이 곧 (계산까지 남은 단계, 피보나치 계산을 위한 첫 번째 수, 피보나치 계산을 위한 두 번째 수) 임을 알 수 있다.\r\n아래 그림은 피보나치 수열이 (1, 1, 2, 3) 까지 계산된 상태에서 2 + 3 = 5를 계산하는 과정(j = 7, (j-2, 2, 3) ⇒ (j-3, 3, 5))에 해당한다.\r\nCairo 프로그램의 증명 과정 : 2. Cairo Bytecode\r\nCairo assembler가 프로그램을 Cairo 바이트코드로 변환하며, 이 단계는 앞서 언급한 4단계 중 2단계에 해당한다.\r\n계산을 위한 Cairo 프로그램을 작성한다.\r\n작성된 프로그램을 Cairo 바이트코드로 변환한다.\r\nCairo Runner가 바이트코드를 실행하여 execution trace S, partial memory function m*, full memory function m을 얻는다.\r\nSTARK prover로 아래 statement에 대한 proof를 생성한다.\"nondeterministic Cairo machine은 input이 ( T, m*, pcI, pc_F, ap_I, ap_F )일 때 accept 한다.\"\r\nCairo 바이트코드는 아래 요소들로 구성되어 있다.\r\nfield element b의 sequence, 즉 b = (b0, … , b{|b|-1})\r\n두 개의 index인 prog_start, prog_endCairo 바이트코드에는 프로그램을 실행하기 위해 필요한 정보가 들어있으며, 프로그램을 실행하고 싶다면 메모리 주소의 기본값인 pr(program base)를 고른 후 이에 맞게 partial memory function m과 pc_I, pc_F를 설정한다. 이는 프로그램을 실행할 때 필요한 메모리의 범위만 있다면 임의의 주소를 선택해 해당 주소부터 시작하여 사용할 수 있게 하기 위함이다.\r\npartial memory function m 은 m*(progbase + i) = b_i, (i 는 [0, |b|])로 설정되며, pc_I와 pc_F는 각각 pc_I = prog_base + prog_start, pc_F = prog_base + prog_end로 설정된다. 즉 |b|개의 element인 b = ( b0 , … , b{|b| -1})는 prog_base부터 prog_base + |b| 에 해당하는 주소의 메모리 값이다.\r\n위 피보나치 프로그램에서 아래와 같은 바이트코드를 얻을 수 있다.\r\n출처 : Cairo whitepaperprog_base를 0이라 가정하면,\r\n이 바이트코드에 의해 partial memory function은 m*(0) = 0x480680017fff8000, m*(1) = 1, m*(2) = 0x480680017fff8000, … 와 같이 설정된다. pc값은 pcI = 0 + 0, pc_F = 0 + 10로 설정된다.\r\n실제로 위 피보나치 코드를 컴파일했을 때 아래와 같은 바이트코드를 얻었다. data 가 b = ( b0 , ... , b{|b| - 1})에 해당한다.\r\n컴파일된 fib-compiled.json 파일Cairo 프로그램의 증명 과정 : 3. Cairo Runner 실행\r\nCairo Runner는 컴파일된 Cairo 프로그램(위와 같은 바이트코드)을 실행하는 프로그램이다. Cairo Runner를 통해 프로그램을 실행하는 것이 세 번째 단계에 해당하며, 실행한 후 proof 생성에 필요한 값들을 얻을 수 있다.\r\n계산을 위한 Cairo 프로그램을 작성한다.\r\n작성된 프로그램을 Cairo 바이트코드로 변환한다.\r\nCairo Runner가 바이트코드를 실행하여 execution trace S, partial memory function m*, full memory function m을 얻는다.\r\nSTARK prover로 아래 statement에 대한 proof를 생성한다.\"nondeterministic Cairo machine은 input이 ( T, m*, pc_I, pc_F, ap_I, ap_F )일 때 accept 한다.\"\r\nCairo Runner는 컴파일된 바이트코드를 실행하며 execution trace, partial memory function과 full memory function을 얻는다. 여기서 execution trace는 위에서 언급했듯이 pc, ap, fp 레지스터 값이며, partial memory function, full memory function은 프로그램이 실행되면서 사용된 메모리 값들에 해당한다.\r\nCairo Runner의 소스 코드는 현재 스타크웨어 깃헙에 공개되어 있으며 (https://github.com/starkware-libs/cairo-lang), 아래 코드는 Cairo Runner 소스 코드 중 컴파일된 json 파일에서 trace(pc, ap, fp)를 기록하는 부분에 해당한다.\r\nclass CairoRunner:\r\ndef init(\r\nself,\r\nprogram: ProgramBase,\r\nlayout: str = \"plain\",\r\nmemory: MemoryDict = None,\r\nproof_mode: Optional[bool] = None,\r\nallow_missing_builtins: Optional[bool] = None,\r\n):\r\nself.program = program\r\nself.layout = layout\r\nself.builtin_runners: Dict[str, BuiltinRunner] = {}\r\nself.original_steps = None\r\nself.proof_mode = False if proof_mode is None else proof_mode\r\nself.allow_missing_builtins = (\r\nFalse if allow_missing_builtins is None else allow_missing_builtins\r\n)\r\n...\r\ndef relocate(self):\r\nself.segment_offsets = self.segments.relocate_segments()\r\nself.relocated_memory = MemoryDict(\r\n{\r\nself.relocate_value(addr): self.relocate_value(value)\r\nfor addr, value in self.vm_memory.items()\r\n}\r\n)\r\nself.relocated_trace = relocate_trace(\r\nself.vm.trace, self.segment_offsets, self.program.prime\r\n)\r\nfor builtin_runner in self.builtin_runners.values():\r\nbuiltin_runner.relocate(self.relocate_value)\r\nCairo Runner 클래스의 메서드인 relocate 는 relocate_trace 메서드를 통해 하나의 instruction을 실행하면서 self.relocated_trace를 업데이트한다.\r\nrelocate_trace 메서드는 현재까지의 trace와 instruction 정보를 받아 새로운 pc, ap, fp 값을 trace에 추가하여 반환한다.\r\ndef relocate_trace(\r\ntrace: List[TraceEntry[MaybeRelocatable]],\r\nsegment_offsets: Dict[int, T],\r\nprime: int,\r\nallow_missing_segments: bool = False,\r\n) -> List[TraceEntry[T]]:\r\nnew_trace: List[TraceEntry[T]] = []\r\ndef relocate_val(x):\r\nreturn relocate_value(x, segment_offsets, prime, allow_missing_segments)\r\nfor entry in trace:\r\nnew_trace.append(\r\nTraceEntry(\r\npc=relocate_val(entry.pc),\r\nap=relocate_val(entry.ap),\r\nfp=relocate_val(entry.fp),\r\n)\r\n)\r\nreturn new_trace\r\nCairo 프로그램의 증명 과정 : 4. STARK proof 생성\r\nCairo Runner가 프로그램을 실행하여 execution trace를 포함한 output을 반환했다면, 이제 proof의 재료가 될 statement를 작성할 수 있다. STARK prover (StarkEx 서비스들은 SHARP - shared prover를 사용한다.)가 statement에 대한 proof를 만들게 되며, 이 과정이 Cairo를 통한 proof 생성의 마지막 단계에 해당한다.\r\n계산을 위한 Cairo 프로그램을 작성한다.\r\n작성된 프로그램을 Cairo 바이트코드로 변환한다.\r\nCairo Runner가 바이트코드를 실행하여 execution trace S, partial memory function m*, full memory function m을 얻는다.\r\nSTARK prover로 아래 statement에 대한 proof를 생성한다.\"nondeterministic Cairo machine은 input이 ( T, m*, pc_I, pc_F, ap_I, ap_F )일 때 accept 한다.\"\r\n먼저 스타크웨어가 제시한 deterministic Cairo machine과 nondeterministic Cairo machine의 개념을 살펴보자.\r\n(수식을 담기 위해 개념 내용은 별도로 정리한 notion 페이지의 내용을 사용)\r\nproof로 만들고자 하는 statement를 다시 살펴보자.\r\n\"nondeterministic Cairo machine은 input이 ( T, m*, pc_I, pc_F, ap_I, ap_F )일 때 accept 한다.\"\r\n이 statement가 성립한다면, 즉 nondeterministic Cairo machine이 ( T, m*, pc_I, pc_F, ap_I, ap_F )을 accept 한다면 deterministic Cairo machine이 accept 하는 input인 ( T, m, S )가 존재함을 나타낸다.\r\n증명은 다음과 같다.\r\nm은 m*을 확장하기 때문에, m*이 포함하는 Cairo 프로그램(편의상 피보나치 프로그램)의 바이트코드는 m에 포함된다. 따라서 프로그램의 모든 step에 대해 memory function을 확인할 수 있다.\r\npc_I = prog_base + prog_start이기 때문에 deterministic Cairo machine이 실행하는 첫 instruction은 피보나치 프로그램의 첫 instruction이다.\r\nT개의 step동안 동일하게 실행된다.\r\npc_F = prog_base + prog_end이기 때문에, 피보나치 프로그램의 마지막 instruction 실행을 확인할 수 있다.결론적으로 deterministic Cairo machine의 output이 accept 라면, 각 step마다 state (pc, ap, fp) transition이 모두 valid함을 나타내며 이는 Cairo로 작성된 프로그램 연산의 유효성을 보장한다.\r\n이 연산의 유효성을 증명해줄 proof가 만들어지면 이는 온체인의 SHARP 컨트랙트로 전달된다. 현재 SHARP 컨트랙트는 이더리움 goerli 테스트넷(https://goerli.etherscan.io/address/0xAB43bA48c9edF4C2C4bB01237348D1D7B28ef168#readContract) 에 배포되어 있다.\r\nSHARP 컨트랙트는 Fact Registry라는 컨트랙트에 fact라는 이름으로 증명(proof)을 작성하여 저장한다. 증명이 만들어졌으니 이를 검증해야 하고, 이 역할은 추후 설명할 Verifier Contract가 담당하게 된다.\r\n이 fact가 온체인에 등록되었으므로 Verifier Contract는 유효성 검증을 위해 이를 사용할 수 있다. Verify Contract의 검증 로직은 이후 시리즈에서 다루기로 한다.\r\n맺음말\r\n스타크웨어는 범용적인 증명의 생성과 검증을 위해 Cairo 언어를 개발하였다. 이 언어가 어떻게 프로그램의 유효성을 증명하는지 살펴보았고, 결국 핵심은 메모리의 불변성을 기반으로 (pc, ap, fp)의 state transition을 통해 프로그램의 유효성을 증명하는 것이었다. 프로그램을 실행하는 것만으로도 유효성을 증명할 수 있다는 것, 또한 그 증명 과정에서 필요한 연산을 최소화했다는 것은 분명 L2 네트워크에서 지속가능한 확장성을 구현하는 데에 일조한다. 그러나 아직 StarkEx에 참여하는 프로젝트들 (dydx, Immutable X, Sorare, DeverseFi)의 Cairo로 작성된 비즈니스 로직이 아직까지 오픈소스로서 공개된 사항은 없으며, 이상적인 스타크웨어 생태계를 위해서는 Cairo의 적용이 더욱 확대되어야 한다. 이를 위해 본 게시글은 Cairo에 대한 아주 기본적인 이해를 돕고 있다.\r\n내용 피드백과 추가적인 질문은 아래 연락처로 부탁드립니다.\r\nemail : lhm0710@snu.ac.kr\r\nReference\r\n[1] Lior Goldberg, Shahar Papini, and Michael Riabzev, \"Cairo - a Turing-complete STARK-friendly CPU architecture\", 2021"}},"/":{"title":"About","data":{"hyemin-lee#Hyemin Lee":"Hi, I'm Hyemin Lee! 👋\nI enjoy solving problems and thinking logically, which naturally led me to work as a software engineer. I'm an adventurous individual who also has a passion for photography and travel.I'm currently interested in CRDT, Zero knowledge proof and distributed system.","work-experience#Work Experience":"","naver-corp-seoul-republic-of-korea#NAVER Corp. (Seoul, Republic of Korea)":"Software Engineer Intern (Jul 2023 - Sep 2023)\nCRDT(Conflict-free replicated data type) Development: Contributed to Yorkie, a document store for collaborative application by developing the software algorithm of multi-user undo and redo feature (issue#652).\nSkills: Go, Typescript, MongoDB, Docker","radius-lab-seoul-republic-of-korea#Radius Lab (Seoul, Republic of Korea)":"Software Engineer (Jan 2022 - Jun 2023)\nPVDE(Practical Verifiable Delay Encryption) implementation: Proposed and implemented PVDE, which was selected for the Ethereum Foundation’s grant program and received $1.7M investment led by Hashed.\nSkills: Rust, Actix-web, Express.js, Docker\n360 DEX Development: Developed 360 DEX interface page and PVDE WASM package for interface. Optimized PVDE execution time by 85% by enabling browser multi-threading with web worker.\nSkills: React.js, WASM, Web worker","hanhwa-life-insurance-co-ltd-seoul-republic-of-korea#Hanhwa Life Insurance co., ltd (Seoul, Republic of Korea)":"Research Assistant Intern (Jun 2021 - Aug 2021)\nBlockchain Research: Published 10+ research papers about blockchain infrastructure and DeFi(AMM) which was used as a learning resource for 2,500+ employees.","elysia-dao-llc-seoul-republic-of-korea#Elysia DAO LLC. (Seoul, Republic of Korea)":"Mobile Application Engineer Intern (Aug 2020 - Feb 2021)\nMobile App Development: Developed Elysia mobile application which have 5,000+ downloads.\nSkills: React.js, React Native, Docker, AWS","education#Education":"","seoul-national-university-seoul-republic-of-korea#Seoul National University (Seoul, Republic of Korea)":"B.S in Rural Systems Engineering (Mar 2017 - Aug 2023)\nB.S in Computer Science and Engineering (Mar 2017 - Aug 2023)\nOutstanding Thesis Award (우수학사 논문발표상), Aug 2023\nB.A in Information Science and Culture (Mar 2017 - Aug 2023)","contacts#Contacts":"GitHub @hyemmie\nMedium @Hyem_mie\nEmail lhm07100@gmail.com"}},"/posts/markdown":{"title":"Markdown Examples","data":{"h2-heading#h2 Heading":"","h3-heading#h3 Heading":"","h4-heading#h4 Heading":"","h5-heading#h5 Heading":"","h6-heading#h6 Heading":"","emphasis#Emphasis":"This is bold textThis is italic textStrikethrough","blockquotes#Blockquotes":"Develop. Preview. Ship. – Vercel","lists#Lists":"Unordered\nLorem ipsum dolor sit amet\nConsectetur adipiscing elit\nInteger molestie lorem at massa\nOrdered\nLorem ipsum dolor sit amet\nConsectetur adipiscing elit\nInteger molestie lorem at massa","code#Code":"Inline code\nexport default function Nextra({ Component, pageProps }) {\n  return (\n    <>\n      <Head>\n        <link\n          rel=\"alternate\"\n          type=\"application/rss+xml\"\n          title=\"RSS\"\n          href=\"/feed.xml\"\n        />\n        <link\n          rel=\"preload\"\n          href=\"/fonts/Inter-roman.latin.var.woff2\"\n          as=\"font\"\n          type=\"font/woff2\"\n          crossOrigin=\"anonymous\"\n        />\n      </Head>\n      <Component {...pageProps} />\n    </>\n  )\n}","tables#Tables":"Option\tDescription\tFirst\tLorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua.\tSecond\tLorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua.\tThird\tLorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua.","links#Links":"Next.js\nNextra\nVercel","footnotes#Footnotes":"Footnote .\nFootnote .\nFootnote can have markupand multiple paragraphs.Footnote text."}},"/photos/hok":{"title":"Hokkaido","data":{"":"Hokkaido!"}},"/posts":{"title":"Posts","data":{}},"/photos":{"title":"Photos","data":{"":"Here's some of my photography. All photos are taken by Sony A7C and Leica mini zoom.","hokkaido#Hokkaido":"","tel-aviv#Tel Aviv":""}},"/projects":{"title":"Projects","data":{"business-projects#Business Projects":"Projects I've worked on at company","individual-projects#Individual Projects":"Projects I've worked on individually","cs-courses-projects#CS Courses Projects":"Projects I've worked on at university"}},"/tags/[tag]":{"title":"Tagged Posts","data":{}},"/posts/pages":{"title":"Next.js Pages","data":{"":"In Next.js, a page is a React Component exported from a .js, .jsx, .ts, or .tsx file in the pages directory. Each page is associated with a route based on its file name.Example: If you create pages/about.js that exports a React component like below, it will be accessible at /about.\nfunction About() {\n  return <div>About</div>\n}\nexport default About","pages-with-dynamic-routes#Pages with Dynamic Routes":"Next.js supports pages with dynamic routes. For example, if you create a file called pages/posts/[id].js, then it will be accessible at posts/1, posts/2, etc.\nTo learn more about dynamic routing, check the Dynamic Routing documentation.","pre-rendering#Pre-rendering":"By default, Next.js pre-renders every page. This means that Next.js generates HTML for each page in advance, instead of having it all done by client-side JavaScript. Pre-rendering can result in better performance and SEO.Each generated HTML is associated with minimal JavaScript code necessary for that page. When a page is loaded by the browser, its JavaScript code runs and makes the page fully interactive. (This process is called hydration.)","two-forms-of-pre-rendering#Two forms of Pre-rendering":"Next.js has two forms of pre-rendering: Static Generation and Server-side Rendering. The difference is in when it generates the HTML for a page.\nStatic Generation (Recommended): The HTML is generated at build time and will be reused on each request.\nServer-side Rendering: The HTML is generated on each request.\nImportantly, Next.js lets you choose which pre-rendering form you'd like to use for each page. You can create a \"hybrid\" Next.js app by using Static Generation for most pages and using Server-side Rendering for others.We recommend using Static Generation over Server-side Rendering for performance reasons. Statically generated pages can be cached by CDN with no extra configuration to boost performance. However, in some cases, Server-side Rendering might be the only option.You can also use Client-side Rendering along with Static Generation or Server-side Rendering. That means some parts of a page can be rendered entirely by client side JavaScript. To learn more, take a look at the Data Fetching documentation.","static-generation-recommended#Static Generation (Recommended)":"If a page uses Static Generation, the page HTML is generated at build time. That means in production, the page HTML is generated when you run next build . This HTML will then be reused on each request. It can be cached by a CDN.In Next.js, you can statically generate pages with or without data. Let's take a look at each case.","static-generation-without-data#Static Generation without data":"By default, Next.js pre-renders pages using Static Generation without fetching data. Here's an example:\nfunction About() {\n  return <div>About</div>\n}\nexport default About\nNote that this page does not need to fetch any external data to be pre-rendered. In cases like this, Next.js generates a single HTML file per page during build time.","static-generation-with-data#Static Generation with data":"Some pages require fetching external data for pre-rendering. There are two scenarios, and one or both might apply. In each case, you can use a special function Next.js provides:\nYour page content depends on external data: Use getStaticProps.\nYour page paths depend on external data: Use getStaticPaths (usually in addition to getStaticProps).","scenario-1-your-page-content-depends-on-external-data#Scenario 1: Your page content depends on external data":"Example: Your blog page might need to fetch the list of blog posts from a CMS (content management system).\n// TODO: Need to fetch `posts` (by calling some API endpoint)\n//       before this page can be pre-rendered.\nfunction Blog({ posts }) {\n  return (\n    <ul>\n      {posts.map((post) => (\n        <li>{post.title}</li>\n      ))}\n    </ul>\n  )\n}\nexport default Blog\nTo fetch this data on pre-render, Next.js allows you to export an async function called getStaticProps from the same file. This function gets called at build time and lets you pass fetched data to the page's props on pre-render.\nfunction Blog({ posts }) {\n  // Render posts...\n}\n// This function gets called at build time\nexport async function getStaticProps() {\n  // Call an external API endpoint to get posts\n  const res = await fetch('https://.../posts')\n  const posts = await res.json()\n  // By returning { props: { posts } }, the Blog component\n  // will receive `posts` as a prop at build time\n  return {\n    props: {\n      posts\n    }\n  }\n}\nexport default Blog\nTo learn more about how getStaticProps works, check out the Data Fetching documentation.","scenario-2-your-page-paths-depend-on-external-data#Scenario 2: Your page paths depend on external data":"Next.js allows you to create pages with dynamic routes. For example, you can create a file called pages/posts/[id].js to show a single blog post based on id. This will allow you to show a blog post with id: 1 when you access posts/1.\nTo learn more about dynamic routing, check the Dynamic Routing documentation.\nHowever, which id you want to pre-render at build time might depend on external data.Example: suppose that you've only added one blog post (with id: 1) to the database. In this case, you'd only want to pre-render posts/1 at build time.Later, you might add the second post with id: 2. Then you'd want to pre-render posts/2 as well.So your page paths that are pre-rendered depend on external data**.** To handle this, Next.js lets you export an async function called getStaticPaths from a dynamic page (pages/posts/[id].js in this case). This function gets called at build time and lets you specify which paths you want to pre-render.\n// This function gets called at build time\nexport async function getStaticPaths() {\n  // Call an external API endpoint to get posts\n  const res = await fetch('https://.../posts')\n  const posts = await res.json()\n  // Get the paths we want to pre-render based on posts\n  const paths = posts.map((post) => ({\n    params: { id: post.id }\n  }))\n  // We'll pre-render only these paths at build time.\n  // { fallback: false } means other routes should 404.\n  return { paths, fallback: false }\n}\nAlso in pages/posts/[id].js, you need to export getStaticProps so that you can fetch the data about the post with this id and use it to pre-render the page:\nfunction Post({ post }) {\n  // Render post...\n}\nexport async function getStaticPaths() {\n  // ...\n}\n// This also gets called at build time\nexport async function getStaticProps({ params }) {\n  // params contains the post `id`.\n  // If the route is like /posts/1, then params.id is 1\n  const res = await fetch(`https://.../posts/${params.id}`)\n  const post = await res.json()\n  // Pass post data to the page via props\n  return { props: { post } }\n}\nexport default Post\nTo learn more about how getStaticPaths works, check out the Data Fetching documentation.","when-should-i-use-static-generation#When should I use Static Generation?":"We recommend using Static Generation (with and without data) whenever possible because your page can be built once and served by CDN, which makes it much faster than having a server render the page on every request.You can use Static Generation for many types of pages, including:\nMarketing pages\nBlog posts\nE-commerce product listings\nHelp and documentation\nYou should ask yourself: \"Can I pre-render this page ahead of a user's request?\" If the answer is yes, then you should choose Static Generation.On the other hand, Static Generation is not a good idea if you cannot pre-render a page ahead of a user's request. Maybe your page shows frequently updated data, and the page content changes on every request.In cases like this, you can do one of the following:\nUse Static Generation with Client-side Rendering: You can skip pre-rendering some parts of a page and then use client-side JavaScript to populate them. To learn more about this approach, check out the Data Fetching documentation.\nUse Server-Side Rendering: Next.js pre-renders a page on each request. It will be slower because the page cannot be cached by a CDN, but the pre-rendered page will always be up-to-date. We'll talk about this approach below.","server-side-rendering#Server-side Rendering":"Also referred to as \"SSR\" or \"Dynamic Rendering\".\nIf a page uses Server-side Rendering, the page HTML is generated on each request.To use Server-side Rendering for a page, you need to export an async function called getServerSideProps. This function will be called by the server on every request.For example, suppose that your page needs to pre-render frequently updated data (fetched from an external API). You can write getServerSideProps which fetches this data and passes it to Page like below:\nfunction Page({ data }) {\n  // Render data...\n}\n// This gets called on every request\nexport async function getServerSideProps() {\n  // Fetch data from external API\n  const res = await fetch(`https://.../data`)\n  const data = await res.json()\n  // Pass data to the page via props\n  return { props: { data } }\n}\nexport default Page\nAs you can see, getServerSideProps is similar to getStaticProps, but the difference is that getServerSideProps is run on every request instead of on build time.To learn more about how getServerSideProps works, check out our Data Fetching documentation","summary#Summary":"We've discussed two forms of pre-rendering for Next.js.\nStatic Generation (Recommended): The HTML is generated at build time and will be reused on each request. To make a page use Static Generation, either export the page component, or export getStaticProps (and getStaticPaths if necessary). It's great for pages that can be pre-rendered ahead of a user's request. You can also use it with Client-side Rendering to bring in additional data.\nServer-side Rendering: The HTML is generated on each request. To make a page use Server-side Rendering, export getServerSideProps. Because Server-side Rendering results in slower performance than Static Generation, use this only if absolutely necessary."}}}